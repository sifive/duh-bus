{
  abstractionDefinition: {
    vendor: 'opencores.org',
    library: 'wishbone',
    name: 'B4_rtl',
    version: '1.0.0',
    busType: {
      vendor: 'opencores.org',
      library: 'wishbone',
      name: 'B4',
      version: '1.0.0'
    },
    ports: {
      // 2.2.2 Signals Common to MASTER and SLAVE Interfaces
      CLK_I: {
        description: 'The clock input [CLK_I] coordinates all activities for the internal logic within the WISHBONE interconnect. All WISHBONE output signals are registered at the rising edge of [CLK_I]. All WISHBONE input signals are stable before the rising edge of [CLK_I].',
        wire: {
          isClock: true,
          onMaster: { presence: 'optional', width: 1, direction: 'in' },
          onSlave:  { presence: 'optional', width: 1, direction: 'in' },
          requiresDriver: true
        }
      },
      RST_I: {
        description: 'The reset input [RST_I] forces the WISHBONE interface to restart. Furthermore, all internal self-starting state machines will be forced into an initial state. This signal only resets the WISHBONE interface. It is not required to reset other parts of an IP core (although it may be used that way).',
        wire: {
          isReset: true,
          onMaster: { presence: 'optional', width: 1, direction: 'in' },
          onSlave:  { presence: 'optional', width: 1, direction: 'in' },
          requiresDriver: true
        }
      },
      DAT_I: {
        description: 'The data input array [DAT_I()] is used to pass binary data. The array boundaries are determined by the port size, with a maximum port size of 64-bits (e.g. [DAT_I(63..0)]). Also see the [DAT_O()] and [SEL_O()] signal descriptions.',
        wire: {
          onMaster: { presence: 'required', direction: 'in' },
          onSlave:  { presence: 'required', direction: 'in' }
        }
      },
      DAT_O: {
        description: 'The data output array [DAT_O()] is used to pass binary data. The array boundaries are determined by the port size, with a maximum port size of 64-bits (e.g. [DAT_I(63..0)]). Also see the [DAT_I()] and [SEL_O()] signal descriptions.',
        wire: {
          onMaster: { presence: 'required', direction: 'out' },
          onSlave:  { presence: 'required', direction: 'out' }
        }
      },
      TGD_I: {
        description: 'Data tag type [TGD_I()] is used on MASTER and SLAVE interfaces. It contains information that is associated with the data input array [DAT_I()], and is qualified by signal [STB_I]. For example, parity protection, error correction and time stamp information can be attached to the data bus. These tag bits simplify the task of defining new signals because their timing (in relation to every bus cycle) is pre-defined by this specification. The name and operation of a data tag must be defined in the WISHBONE DATASHEET.',
        wire: {
          onMaster: { presence: 'required', direction: 'in' },
          onSlave:  { presence: 'required', direction: 'in' }
        }
      },
      TGD_O: {
        description: 'Data tag type [TGD_O()] is used on MASTER and SLAVE interfaces. It contains information that is associated with the data output array [DAT_O()], and is qualified by signal [STB_O]. For example, parity protection, error correction and time stamp information can be attached to the data bus. These tag bits simplify the task of defining new signals because their timing (in relation to every bus cycle) is pre-defined by this specification. The name and operation of a data tag must be defined in the WISHBONE DATASHEET.',
        wire: {
          onMaster: { presence: 'required', direction: 'out' },
          onSlave:  { presence: 'required', direction: 'out' }
        }
      },
      // 2.2.3 MASTER Signals
      ACK_I: {
        description: 'The acknowledge input [ACK_I], when asserted, indicates the normal termination of a bus cycle. Also see the [ERR_I] and [RTY_I] signal descriptions.',
        wire: {
          onMaster: { presence: 'required', width: 1, direction: 'in' },
          onSlave:  { presence: 'illegal' }
        }
      },
      CYC_O: {
        description: 'The cycle output [CYC_O], when asserted, indicates that a valid bus cycle is in progress. The signal is asserted for the duration of all bus cycles. For example, during a BLOCK transfer cycle there can be multiple data transfers. The [CYC_O] signal is asserted during the first data transfer, and remains asserted until the last data transfer. The [CYC_O] signal is useful for interfaces with multi-port interfaces (such as dual port memories). In these cases, the [CYC_O] signal requests use of a common bus from an arbiter.',
        wire: {
          onMaster: { presence: 'required', width: 1, direction: 'out' },
          onSlave:  { presence: 'illegal' }
        }
      },
      STALL_I: {
        description: 'The pipeline stall input [STALL_I] indicates that current slave is not able to accept the transfer in the transaction queue. This signal is used in pipelined mode.',
        wire: {
          onMaster: { presence: 'required', width: 1, direction: 'in' },
          onSlave:  { presence: 'illegal' }
        }
      },
      ERR_I: {
        description: 'The error input [ERR_I] indicates an abnormal cycle termination. The source of the error, and the response generated by the MASTER is defined by the IP core supplier. Also see the [ACK_I] and [RTY_I] signal descriptions.',
        wire: {
          onMaster: { presence: 'required', width: 1, direction: 'in' },
          onSlave:  { presence: 'illegal' }
        }
      },
      LOCK_O: {
        description: 'The lock output [LOCK_O] when asserted, indicates that the current bus cycle is uninterruptible. Lock is asserted to request complete ownership of the bus. Once the transfer has started, the INTERCON does not grant the bus to any other MASTER, until the current MASTER negates [LOCK_O] or [CYC_O].',
        wire: {
          onMaster: { presence: 'required', width: 1, direction: 'out' },
          onSlave:  { presence: 'illegal' }
        }
      },
      RTY_I: {
        description: 'The retry input [RTY_I] indicates that the interface is not ready to accept or send data, and that the cycle should be retried. When and how the cycle is retried is defined by the IP core supplier. Also see the [ERR_I] and [RTY_I] signal descriptions.',
        wire: {
          onMaster: { presence: 'required', width: 1, direction: 'in' },
          onSlave:  { presence: 'illegal' }
        }
      },
      SEL_O: {
        description: 'The select output array [SEL_O()] indicates where valid data is expected on the [DAT_I()] signal array during READ cycles, and where it is placed on the [DAT_O()] signal array during WRITE cycles. The array boundaries are determined by the granularity of a port. For example, if 8-bit granularity is used on a 64-bit port, then there would be an array of eight select signals with boundaries of [SEL_O(7..0)]. Each individual select signal correlates to one of eight active bytes on the 64-bit data port. For more information about [SEL_O()], please refer to the data organization section in Chapter 3 of this specification. Also see the [DAT_I()], [DAT_O()] and [STB_O] signal descriptions.',
        wire: {
          onMaster: { presence: 'required', width: 1, direction: 'out' },
          onSlave:  { presence: 'illegal' }
        }
      },
      STB_O: {
        description: 'The strobe output [STB_O] indicates a valid data transfer cycle. It is used to qualify various other signals on the interface such as [SEL_O()]. The SLAVE asserts either the [ACK_I], [ERR_I] or [RTY_I] signals in response to every assertion of the [STB_O] signal.',
        wire: {
          onMaster: { presence: 'required', width: 1, direction: 'out' },
          onSlave:  { presence: 'illegal' }
        }
      },
      TGA_O: {
        description: 'Address tag type [TGA_O()] contains information associated with address lines [ADR_O()], and is qualified by signal [STB_O]. For example, address size (24-bit, 32-bit etc.) and memory management (protected vs. unprotected) information can be attached to an address. These tag bits simplify the task of defining new signals because their timing (in relation to every bus cycle) is defined by this specification. The name and operation of an address tag must be defined in the WISHBONE DATASHEET.',
        wire: {
          onMaster: { presence: 'required', direction: 'out' },
          onSlave:  { presence: 'illegal' }
        }
      },
      TGC_O: {
        description: 'Cycle tag type [TGC_O()] contains information associated with bus cycles, and is qualified by signal [CYC_O]. For example, data transfer, interrupt acknowledge and cache control cycles can be uniquely identified with the cycle tag. They can also be used to discriminate between WISHBONE SINGLE, BLOCK and RMW cycles. These tag bits simplify the task of defining new signals because their timing (in relation to every bus cycle) is defined by this specification. The name and operation of a cycle tag must be defined in the WISHBONE DATASHEET.',
        wire: {
          onMaster: { presence: 'required', direction: 'out' },
          onSlave:  { presence: 'illegal' }
        }
      },
      WE_O: {
        description: 'The write enable output [WE_O] indicates whether the current local bus cycle is a READ or WRITE cycle. The signal is negated during READ cycles, and is asserted during WRITE cycles.',
        wire: {
          onMaster: { presence: 'required', width: 1, direction: 'out' },
          onSlave:  { presence: 'illegal' }
        }
      },
      // 2.2.4 SLAVE Signals
      ACK_O: {
        description: 'The acknowledge output [ACK_O], when asserted, indicates the termination of a normal bus cycle. Also see the [ERR_O] and [RTY_O] signal descriptions.',
        wire: {
          onMaster: { presence: 'illegal' },
          onSlave:  { presence: 'required', width: 1, direction: 'out' }
        }
      },
      ADR_I: {
        description: 'The address input array [ADR_I()] is used to pass a binary address. The higher array boundary is specific to the address width of the core, and the lower array boundary is determined by the data port size. For example the array size on a 32-bit data port with BYTE granularity is [ADR_O(n..2)]. In some cases (such as FIFO interfaces) the array may not be present on the interface.',
        wire: {
          onMaster: { presence: 'illegal' },
          onSlave:  { presence: 'required', direction: 'out' }
        }
      }
    }
  }
}
